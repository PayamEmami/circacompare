---
title: "Introduction to using circacompare"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{circacompare-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 3.5
)
set.seed(42)
# rmarkdown::render("vignettes/circacompare-vignette.Rmd")
```

```{r, message=F, warning=F}
library(circacompare)
library(ggplot2)

data_single <- make_data(k1=0, alpha1=0, phi1=0, noise_sd=1)[c("time", "measure")]
data_grouped <- make_data(phi1=6, noise_sd=1)
```

## Updates since the initial release and Bioinformatics journal article

There have been several added features to the package since the publication in Bioinformatics, and many of the possible uses for this package are not described in the publication.  The approach to compare two groups of rhythmic data described in the manuscript can be completed by using the `circacompare()` function under the default settings. In addition to this, the package offers approaches to:

* Perform analysis on a single rhythmic dataset to estimate its mesor, amplitude and phase.
* Choose to use a known period (user-determined) or to let the model estimate the period from the data.
* Add parameters to estimate the exponential decay in any of the rhythmic characteristics.
* Use a mixed-model instead of a fixed effects model to take into account within-subject correlation regarding any set of rhythmic parameters.
* Perform a comparison between groups all or a subset of rhythmic characteristics.


## Introduction to circacompare, using fixed-effects only models and no customized parametrization

### Input data

The first part of using circacompare to analyse your data is to ensure that your data is formatted correctly.
All of the functions within the circacompare package expect that your data will be of a tidy format, meaning that each row will contain only one observation, with columns to represent the time, group or subject ID for that observation. 

In the simplest case, you may have a single rhythm for which you're wanting to estimate the mesor, amplitude and phase.  In this case, you only need a variable for the time of observation and the outcome which you're wanting to model.

```{r}
head(data_single)
```
In the case that you have data from two groups and you're wishing to determine the differences in mesor, amplitude, or phase between them, you will need an additional column (with two possible values) representing the groups.

```{r}
head(data_grouped)
tail(data_grouped)
```


### `circa_single()`

`circa_single()` is used to analyse a single rhythm and provide estimates of its mesor, amplitude and phase.

```{r}
result <- circa_single(x=data_single, col_time="time", col_outcome="measure", period=24)

result
```

The fitted model is included as the first element of the results.  

It fits a model: `measure ~ k + alpha * cos(time_r - phi)` where

* `measure` is the outcome of interest

* `k` is the mesor

* `alpha` is the amplitude

* `time_r` is the time in radian-hours, and

* `phi` is the amount of phase shift (from `time=0`) in radian-hours.

The parameter estimates of time in radian-hours (`time_r` and `phi`) are converted back to hours and reported in the `data.frame` (second element of list) and x-axis of the graph (third item of list)


### `circacompare()`

`circacompare()` is used to analyse a dataset with two groups of rhythmic data. It fits a model to estimate and statistically support differences in mesor, amplitude and phase between the two groups.

```{r}
result2 <- circacompare(x=data_grouped, col_time="time", col_group="group", col_outcome="measure")

result2
```

This fits a model: `measure ~ k + k1 * x_group + (alpha + alpha1 * x_group) * cos(time_r - (phi + phi1 * x_group))` where

* `x_group` is a dummy variable which represents the different groups: `x_group=0` and `x_group=1` for the first and second group, respectively

* `measure` is the outcome of interest

* `k` is the mesor of the first group

* `k1` is the difference in mesor between the first and second group

* `alpha` is the amplitude of the first group

* `alpha1` is the difference in amplitude between the first and second group

* `time_r` is the time in radian-hours

* `phi` is the amount of phase-shift of the first group (from `time=0`) in radian-hours, and

* `phi1` is the amount of phase-shift of the second group from the first group in radian-hours


The time-related parameter estimates (`phi` and `phi1`) are converted from radian-hours to hours before being used to report `g1 peak time`, `g2 peak time`, and `phase difference estimate`.

The second item of the `result2` list is a data.frame containing the important results from the model.  It returns estimates and for the rhythmic parameters for each group as well as the p-values associated with those which represent differences between the groups (`k1`, `alpha1`, `phi1`).

More detailed outputs from the model can be obtained from the model itself


### When to use what

If you are looking to estimate the rhythmic parameters of a single group, use `circa_single()`.
If you are looking to estimate the differences between two rhythmic datasets, use `circacompare()`

If your data has a hierarchical structure, a mixed model may be more appropriate (keep reading). This may be the case if you have repeated measurements from the same subjects/tissues over time, for example. In this case, consider the equivalents of the above: `circa_single_mixed()` and `circacompare_mixed()`.  In addition to what has been described, these mixed models require the user to specify which parameters ought to have a random effect and the identifying column (`col_id`) for this hierarchical structure.


## Mixed-model variants and customized parametrization

If you have repeated measures data, then it may be inappropriate to use a standard fixed effects only model. In this case, you should use a mixed model, with context-relevant random effects for the individual.

Here, I have some data that has some simulated within-id correlation in terms of the amount of phase shift between groups. 

```{r}
phi1_in <- 3.15
mixed_data <- function(n){
  counter <- 1
  for(i in 1:n){
    x <- make_data(k1=0, alpha1=5, phi1=rnorm(1, phi1_in, 1), hours=72, noise_sd = 2)
    x$id <- counter
    counter <- counter + 1
    if(i==1){res <- x}else{res <- rbind(res, x)}
  }
  return(res)
}
df <- mixed_data(20)
out <- circacompare_mixed(
  x = df,
  col_time = "time",
  col_group = "group",
  col_outcome = "measure",
  col_id = "id",
  control=list(grouped_params=c("alpha", "phi"), random_params=c("phi1")),
  period=24
)

ggplot(data=df[df$id %in% c(1:6),], aes(time, measure)) + 
  geom_point(aes(col=group)) + 
  geom_smooth(aes(group=interaction(as.factor(id), group)), span=0.3)+
  facet_wrap(~id)

```

For each ID, there are measurements in both groups (g1 and g2) but the degree of change in phase is ID-dependent.  The phase of group 1 is not ID-dependent, though, it's the amount of phase shift from g1 to g2 that is.  For this reason, we want to have a "random-slope" on the phase, so we should include "phi1" as a random effect. Also, since I know, from the data generating process, that both groups share the same mesor but not amplitude, I included `alpha` and `phi` as grouped parameters, but excluded `k`. I also know that the period is 24 hours, so I didn't bother fitting a parameter for `tau` either.

From the data generating process used above, we expect:

* `phi1=1.5`
* `k1=3`
* `alpha1=5`

```{r}
out$plot

summary <- as.data.frame(circacompare:::extract_model_coefs(out$fit))
summary$`95% CI ll` <- summary$estimate - summary$std_error*1.96
summary$`95% CI ul` <- summary$estimate + summary$std_error*1.96

summary
```

The effects were all pretty well estimated, with each of the estimates being within the 95% confidence intervals from the model.  If we expect the subject's to have different starting phases but their change in phase between groups to be the same, we may have put the random effect on `phi` rather than `phi1`. 

Perhaps more commonly applicable would be if each subject has some random midpoint (baseline expression levels of the outcome).  In this case, it may be worthwhile to include `k` as a random effect. If `k` is included, this is equivalent to giving everyone (irrespective of group that they're assigned, if each subject is only included in one group) a "random intercept".


## Decay parameters and parametrizing period

There is the option to model the decay of parameters, as well as adding parameters to measure the difference in decay between groups. In this mode detailed model, we make simulated data with no difference in mesor or phase between groups, an unknown period (somewhere between 8 and 20 hours) that we want to estimate, and one group which has exponentially decaying amplitude at the rate:

$$
\alpha*e^{-\alpha_{decay}*t}
$$
Where `alpha` is the amplitude, and `t` is time in radian-hours.

In our case, `alpha_decay` will be an unknown value, somewhere between 0.05 and 0.3.

To model these data, we will include all the standard parameters as well as `tau` (to control the period) in the `main_params`:
  `main_params=c("k", "alpha", "phi", "tau")`

We will include a term for amplitude in the `decay_params`:
  `decay_params=c("alpha")`

And we will model the differences between groups for `alpha` and `alpha_decay`:
  `grouped_params=c("alpha", "alpha_decay")`

This produces the following model:
`measure~k+((alpha+alpha1*x_group)*exp(-(alpha_decay+alpha_decay1*x_group)*time_r))*cos((24/(tau))*time_r-(phi))`

```{r}
tau_in <- runif(1, 8, 20)
alpha_decay1_in <- runif(1, 0.05, 0.3)

df <- make_data(k1=0, alpha1=10, phi1=0, seed=42, hours=96, noise_sd=2)
df$time <- df$time/24*tau_in

# note that decay is on a scale of time in radians, not time in hours.
df$measure[df$group=="g2"] <- df$measure[df$group=="g2"]*exp(-alpha_decay1_in*(df$time*2*pi/24)[df$group=="g2"])
out_alpha_decay <-
  circacompare(x=df, "time", "group", "measure", period=NA,
  control=list(
  main_params=c("k", "alpha", "phi", "tau"),
  decay_params=c("alpha"),
  grouped_params=c("alpha", "alpha_decay")
))

out_alpha_decay$plot

summary <- as.data.frame(circacompare:::extract_model_coefs(out_alpha_decay$fit))
summary$`95% CI ll` <- summary$estimate - summary$std_error*1.96
summary$`95% CI ul` <- summary$estimate + summary$std_error*1.96
summary

```
We now have estimates for the decay and the period, which were of interest.  Lets see the real values and check that they fell within the confidence intervals?

```{r}
cat("Real period: ", tau_in, "\n\n",
    "Real alpha_decay: ", alpha_decay1_in, sep="")
```

Looks like our estimates and confidence intervals suited our now-known data generating process well!


## Period and phase parameters

It may be tempting to investigate the differences between two groups of rhythmic data regarding everything! But, unfortunately, there are limitations. If two groups of data are allowed to vary regarding their period, the interpretation of a difference in phase is no longer sensical.  For this reason, you cannot have both `tau` and `phi` within `group_params` in either `circacompare()` or `circacompare_mixed()`.



